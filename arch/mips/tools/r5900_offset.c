/*
 * r5900_offset.c -  Calculate r5900 structs offsets.
 *
 *        Copyright (C) 2000, 2001  Sony Computer Entertainment Inc.
 *
 * This file is subject to the terms and conditions of the GNU General
 * Public License Version 2. See the file "COPYING" in the main
 * directory of this archive for more details.
 *
 */

#include <linux/autoconf.h>
#include <linux/types.h>
#include <linux/sched.h>

#include <linux/perf_dev.h>
#include <asm/sys_r5900.h>
#include "../kernel/r5900_pc_ops.h"

#define text(t) __asm__("\n@@@" t)
#define _offset(type, member) (&(((type *)NULL)->member))

#define offset(string, ptr, member) \
	__asm__("\n@@@" string "%0" : : "i" (_offset(ptr, member)))
#define size(string, size) \
	__asm__("\n@@@" string "%0" : : "i" (sizeof(size)))
#define linefeed text("")

text("/* DO NOT TOUCH, AUTOGENERATED BY R5900_OFFSET.C */");
linefeed;
text("#ifndef _MIPS_R5900_OFFSET_H");
text("#define _MIPS_R5900_OFFSET_H");
linefeed;

#ifdef CONFIG_CONTEXT_R5900
void output_ptreg_defines(void)
{
	text("/* r5900 pt_regs offsets. */");
	offset("#define PT_SA      ", struct pt_regs, sa);
	linefeed;
}

void output_sc_defines(void)
{
	text("/* r5900 sigcontext offsets. */");
	offset("#define SC_SA          ", struct sigcontext, sc_sa);
	offset("#define SC_FP_ACC      ", struct sigcontext, sc_fp_acc);
	linefeed;
}

void output_thread_defines(void)
{
	text("/* r5900 specific thread_struct offsets. */");
        offset("#define THREAD_FPU_ACC   ", 
			struct task_struct, tss.fpu.hard.fp_acc);
	linefeed;
}
#endif

void output_r5900_upper_ctrs_defines(void)
{
	text("/* r5900  r5900_upper_ctrs offsets. */");
	offset("#define UPPER_CTRS_CTR0   ", struct r5900_upper_ctrs, ctr0);
	offset("#define UPPER_CTRS_CTR1   ", struct r5900_upper_ctrs, ctr1);
	size(  "#define UPPER_CTRS_SIZE   ", struct r5900_upper_ctrs);
	linefeed;
}

void output_pc_sample_entry_defines(void)
{
	struct perf_sample_entry perf_sample_entry;
	text("/* r5900  perf_sample_entry offsets. */");
	offset("#define PERF_ENTRY_PC      ", struct perf_sample_entry, pc);
	offset("#define PERF_ENTRY_PID     ", struct perf_sample_entry, pid);
	offset("#define PERF_ENTRY_EVENT   ", struct perf_sample_entry, event);
	offset("#define PERF_ENTRY_CID     ", struct perf_sample_entry, cid);
	offset("#define PERF_ENTRY_JIFFIES ", struct perf_sample_entry, 
						jiffies);
	size(  "#define PERF_ENTRY_SIZE    ", struct perf_sample_entry);
	size(  "#define SIZEOF_JIFFIES     ", perf_sample_entry.jiffies);
	linefeed;
}

void output_ctrpair_defines(void)
{
	text("/* r5900 ctrset_struct offsets. */");
	offset("#define CTRPAIR_CUR0      ", struct ctrpair_struct, current0);
	offset("#define CTRPAIR_CUR1      ", struct ctrpair_struct, current1);
	offset("#define CTRPAIR_VAL0      ", struct ctrpair_struct, val0);
	offset("#define CTRPAIR_VAL1      ", struct ctrpair_struct, val1);
	offset("#define CTRPAIR_EV0       ", struct ctrpair_struct, event0);
	offset("#define CTRPAIR_EV1       ", struct ctrpair_struct, event1);
	size(  "#define CTRPAIR_SIZE      ", struct ctrpair_struct);
	linefeed;
}

void output_pc_record_defines(void)
{
	text("/* r5900  pc_record offsets. */");
	offset("#define PC_RECORD_DEBUG_BASE ", struct pc_record, debug_base);
	offset("#define PC_RECORD_DEBUG_PTR ", struct pc_record, debug_ptr);
	offset("#define PC_RECORD_POOL_IN ", struct pc_record, pool_in);
	offset("#define PC_RECORD_POOL_OUT ", struct pc_record, pool_out);
	offset("#define PC_RECORD_POOL_NUM ", struct pc_record, pool_num);
	offset("#define PC_RECORD_LOST    ", struct pc_record, lost);
	offset("#define PC_RECORD_MAX_ENTRY ", struct pc_record, max_entry);

	offset("#define PC_RECORD_P0BUFFER  "
				, struct pc_record, buffer_pool[0].p_buffer);
	offset("#define PC_RECORD_P0NUMENT  "
				, struct pc_record, buffer_pool[0].num_entry);
	offset("#define PC_RECORD_RELOAD0 ", struct pc_record, reload0);
	offset("#define PC_RECORD_RELOAD1 ", struct pc_record, reload1);
	offset("#define PC_RECORD_MODE    ", struct pc_record, sample_mode);
	offset("#define PC_RECORD_CUR_NUM ", struct pc_record, 
							cur_ctrpair_num);
	offset("#define PC_RECORD_CUR_PAIR  ", struct pc_record, 
							cur_ctrpair);
	offset("#define PC_RECORD_INIT_PAIR ", struct pc_record, 
							init_ctrpair);
	offset("#define PC_RECORD_NUM_PAIR  ", struct pc_record, 
							num_of_ctrpair);
	offset("#define PC_RECORD_REG_A0  ", struct pc_record, reg_a0);
	offset("#define PC_RECORD_REG_A1  ", struct pc_record, reg_a1);
	offset("#define PC_RECORD_REG_A2  ", struct pc_record, reg_a2);
	offset("#define PC_RECORD_NUM_IPID ", struct pc_record, num_ipid);
	offset("#define PC_RECORD_IGNORE   ", struct pc_record, ignore);
	offset("#define PC_RECORD_IPID     ", struct pc_record, ipid);
	size(  "#define PC_RECORD_SIZE    ", struct pc_record);
	size(  "#define PC_BUFFDESCR_SIZE    ", struct pc_buffer_descr);
	linefeed;
}

void output_task_defines(void)
{
	struct task_struct task_struct;
	text("/* r5900 task_struct offsets. */");
	offset("#define TASK_PID         ", struct task_struct, pid);
	size(  "#define SIZEOF_PID       ", task_struct.pid);
	linefeed;
}
text("#endif /* !(_MIPS_R5900_OFFSET_H) */");
